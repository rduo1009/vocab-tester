from _typeshed import Incomplete

from nltk.featstruct import FeatDict
from nltk.probability import ImmutableProbabilisticMixIn

__all__ = [
    "Nonterminal",
    "nonterminals",
    "CFG",
    "Production",
    "PCFG",
    "ProbabilisticProduction",
    "DependencyGrammar",
    "DependencyProduction",
    "ProbabilisticDependencyGrammar",
    "induce_pcfg",
    "read_grammar",
]

class Nonterminal:
    def __init__(self, symbol: Incomplete) -> None: ...
    def symbol(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...
    def __div__(self, rhs: Incomplete) -> Incomplete: ...
    def __truediv__(self, rhs: Incomplete) -> Incomplete: ...

def nonterminals(symbols: Incomplete) -> Incomplete: ...

class FeatStructNonterminal(FeatDict, Nonterminal):
    def __hash__(self) -> Incomplete: ...
    def symbol(self) -> Incomplete: ...

class Production:
    def __init__(self, lhs: Incomplete, rhs: Incomplete) -> None: ...
    def lhs(self) -> Incomplete: ...
    def rhs(self) -> Incomplete: ...
    def __len__(self) -> int: ...
    def is_nonlexical(self) -> Incomplete: ...
    def is_lexical(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

class DependencyProduction(Production): ...

class ProbabilisticProduction(Production, ImmutableProbabilisticMixIn):
    def __init__(
        self, lhs: Incomplete, rhs: Incomplete, **prob: Incomplete
    ) -> None: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

class CFG:
    def __init__(
        self,
        start: Incomplete,
        productions: Incomplete,
        calculate_leftcorners: bool = True,
    ) -> None: ...
    @classmethod
    def fromstring(
        cls: Incomplete, input: Incomplete, encoding: Incomplete | None = None
    ) -> Incomplete: ...
    def start(self) -> Incomplete: ...
    def productions(
        self,
        lhs: Incomplete | None = None,
        rhs: Incomplete | None = None,
        empty: bool = False,
    ) -> Incomplete: ...
    def leftcorners(self, cat: Incomplete) -> Incomplete: ...
    def is_leftcorner(
        self, cat: Incomplete, left: Incomplete
    ) -> Incomplete: ...
    def leftcorner_parents(self, cat: Incomplete) -> Incomplete: ...
    def check_coverage(self, tokens: Incomplete) -> None: ...
    def is_lexical(self) -> Incomplete: ...
    def is_nonlexical(self) -> Incomplete: ...
    def min_len(self) -> Incomplete: ...
    def max_len(self) -> Incomplete: ...
    def is_nonempty(self) -> Incomplete: ...
    def is_binarised(self) -> Incomplete: ...
    def is_flexible_chomsky_normal_form(self) -> Incomplete: ...
    def is_chomsky_normal_form(self) -> Incomplete: ...
    def chomsky_normal_form(
        self, new_token_padding: str = "@$@", flexible: bool = False
    ) -> Incomplete: ...
    @classmethod
    def remove_unitary_rules(
        cls: Incomplete, grammar: Incomplete
    ) -> Incomplete: ...
    @classmethod
    def binarize(
        cls: Incomplete, grammar: Incomplete, padding: str = "@$@"
    ) -> Incomplete: ...
    @classmethod
    def eliminate_start(
        cls: Incomplete, grammar: Incomplete
    ) -> Incomplete: ...

class FeatureGrammar(CFG):
    def __init__(self, start: Incomplete, productions: Incomplete) -> None: ...
    @classmethod
    def fromstring(
        cls: Incomplete,
        input: Incomplete,
        features: Incomplete | None = None,
        logic_parser: Incomplete | None = None,
        fstruct_reader: Incomplete | None = None,
        encoding: Incomplete | None = None,
    ) -> Incomplete: ...
    def productions(
        self,
        lhs: Incomplete | None = None,
        rhs: Incomplete | None = None,
        empty: bool = False,
    ) -> Incomplete: ...
    def leftcorners(self, cat: Incomplete) -> None: ...
    def leftcorner_parents(self, cat: Incomplete) -> None: ...

class FeatureValueType:
    def __init__(self, value: Incomplete) -> None: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

class DependencyGrammar:
    def __init__(self, productions: Incomplete) -> None: ...
    @classmethod
    def fromstring(cls: Incomplete, input: Incomplete) -> Incomplete: ...
    def contains(self, head: Incomplete, mod: Incomplete) -> Incomplete: ...
    def __contains__(self, head_mod: Incomplete) -> bool: ...

class ProbabilisticDependencyGrammar:
    def __init__(
        self, productions: Incomplete, events: Incomplete, tags: Incomplete
    ) -> None: ...
    def contains(self, head: Incomplete, mod: Incomplete) -> Incomplete: ...

class PCFG(CFG):
    EPSILON: float
    def __init__(
        self,
        start: Incomplete,
        productions: Incomplete,
        calculate_leftcorners: bool = True,
    ) -> None: ...
    @classmethod
    def fromstring(
        cls: Incomplete, input: Incomplete, encoding: Incomplete | None = None
    ) -> Incomplete: ...

def induce_pcfg(start: Incomplete, productions: Incomplete) -> Incomplete: ...
def read_grammar(
    input: Incomplete,
    nonterm_parser: Incomplete,
    probabilistic: bool = False,
    encoding: Incomplete | None = None,
) -> Incomplete: ...
