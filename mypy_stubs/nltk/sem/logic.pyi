from _typeshed import Incomplete

from nltk.internals import Counter as Counter
from nltk.util import Trie as Trie

APP: str

class Tokens:
    LAMBDA: str
    LAMBDA_LIST: Incomplete
    EXISTS: str
    EXISTS_LIST: Incomplete
    ALL: str
    ALL_LIST: Incomplete
    IOTA: str
    IOTA_LIST: Incomplete
    DOT: str
    OPEN: str
    CLOSE: str
    COMMA: str
    NOT: str
    NOT_LIST: Incomplete
    AND: str
    AND_LIST: Incomplete
    OR: str
    OR_LIST: Incomplete
    IMP: str
    IMP_LIST: Incomplete
    IFF: str
    IFF_LIST: Incomplete
    EQ: str
    EQ_LIST: Incomplete
    NEQ: str
    NEQ_LIST: Incomplete
    BINOPS: Incomplete
    QUANTS: Incomplete
    PUNCT: Incomplete
    TOKENS: Incomplete
    SYMBOLS: Incomplete

def boolean_ops() -> None: ...
def equality_preds() -> None: ...
def binding_ops() -> None: ...

class LogicParser:
    type_check: Incomplete
    quote_chars: Incomplete
    operator_precedence: Incomplete
    right_associated_operations: Incomplete
    def __init__(self, type_check: bool = False) -> None: ...
    def parse(
        self, data: Incomplete, signature: Incomplete | None = None
    ) -> Incomplete: ...
    def process(self, data: Incomplete) -> Incomplete: ...
    def process_quoted_token(
        self, data_idx: Incomplete, data: Incomplete
    ) -> Incomplete: ...
    def get_all_symbols(self) -> Incomplete: ...
    def inRange(self, location: Incomplete) -> Incomplete: ...
    def token(self, location: Incomplete | None = None) -> Incomplete: ...
    def isvariable(self, tok: Incomplete) -> Incomplete: ...
    def process_next_expression(self, context: Incomplete) -> Incomplete: ...
    def handle(self, tok: Incomplete, context: Incomplete) -> Incomplete: ...
    def attempt_adjuncts(
        self, expression: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def handle_negation(
        self, tok: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def make_NegatedExpression(self, expression: Incomplete) -> Incomplete: ...
    def handle_variable(
        self, tok: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def get_next_token_variable(
        self, description: Incomplete
    ) -> Incomplete: ...
    def handle_lambda(
        self, tok: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def handle_quant(
        self, tok: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def get_QuantifiedExpression_factory(
        self, tok: Incomplete
    ) -> Incomplete: ...
    def make_QuanifiedExpression(
        self, factory: Incomplete, variable: Incomplete, term: Incomplete
    ) -> Incomplete: ...
    def handle_open(
        self, tok: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def attempt_EqualityExpression(
        self, expression: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def make_EqualityExpression(
        self, first: Incomplete, second: Incomplete
    ) -> Incomplete: ...
    def attempt_BooleanExpression(
        self, expression: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def get_BooleanExpression_factory(self, tok: Incomplete) -> Incomplete: ...
    def make_BooleanExpression(
        self, factory: Incomplete, first: Incomplete, second: Incomplete
    ) -> Incomplete: ...
    def attempt_ApplicationExpression(
        self, expression: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def make_ApplicationExpression(
        self, function: Incomplete, argument: Incomplete
    ) -> Incomplete: ...
    def make_VariableExpression(self, name: Incomplete) -> Incomplete: ...
    def make_LambdaExpression(
        self, variable: Incomplete, term: Incomplete
    ) -> Incomplete: ...
    def has_priority(
        self, operation: Incomplete, context: Incomplete
    ) -> Incomplete: ...
    def assertNextToken(self, expected: Incomplete) -> None: ...
    def assertToken(self, tok: Incomplete, expected: Incomplete) -> None: ...

def read_logic(
    s: Incomplete,
    logic_parser: Incomplete | None = None,
    encoding: Incomplete | None = None,
) -> Incomplete: ...

class Variable:
    name: Incomplete
    def __init__(self, name: Incomplete) -> None: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def substitute_bindings(self, bindings: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

def unique_variable(
    pattern: Incomplete | None = None, ignore: Incomplete | None = None
) -> Incomplete: ...
def skolem_function(univ_scope: Incomplete | None = None) -> Incomplete: ...

class Type:
    def __hash__(self) -> Incomplete: ...
    @classmethod
    def fromstring(cls: Incomplete, s: Incomplete) -> Incomplete: ...

class ComplexType(Type):
    first: Incomplete
    second: Incomplete
    def __init__(self, first: Incomplete, second: Incomplete) -> None: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete
    def matches(self, other: Incomplete) -> Incomplete: ...
    def resolve(self, other: Incomplete) -> Incomplete: ...
    def str(self) -> Incomplete: ...

class BasicType(Type):
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete
    def matches(self, other: Incomplete) -> Incomplete: ...
    def resolve(self, other: Incomplete) -> Incomplete: ...

class EntityType(BasicType):
    def str(self) -> Incomplete: ...

class TruthValueType(BasicType):
    def str(self) -> Incomplete: ...

class EventType(BasicType):
    def str(self) -> Incomplete: ...

class AnyType(BasicType, ComplexType):
    def __init__(self) -> None: ...
    @property
    def first(self) -> Incomplete: ...
    @property
    def second(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete
    def matches(self, other: Incomplete) -> Incomplete: ...
    def resolve(self, other: Incomplete) -> Incomplete: ...
    def str(self) -> Incomplete: ...

TRUTH_TYPE: Incomplete
ENTITY_TYPE: Incomplete
EVENT_TYPE: Incomplete
ANY_TYPE: Incomplete

def read_type(type_string: Incomplete) -> Incomplete: ...

class TypeException(Exception):
    def __init__(self, msg: Incomplete) -> None: ...

class InconsistentTypeHierarchyException(TypeException):
    def __init__(
        self, variable: Incomplete, expression: Incomplete | None = None
    ) -> None: ...

class TypeResolutionException(TypeException):
    def __init__(
        self, expression: Incomplete, other_type: Incomplete
    ) -> None: ...

class IllegalTypeException(TypeException):
    def __init__(
        self,
        expression: Incomplete,
        other_type: Incomplete,
        allowed_type: Incomplete,
    ) -> None: ...

def typecheck(
    expressions: Incomplete, signature: Incomplete | None = None
) -> Incomplete: ...

class SubstituteBindingsI:
    def substitute_bindings(self, bindings: Incomplete) -> None: ...
    def variables(self) -> None: ...

class Expression(SubstituteBindingsI):
    @classmethod
    def fromstring(
        cls: Incomplete,
        s: Incomplete,
        type_check: bool = False,
        signature: Incomplete | None = None,
    ) -> Incomplete: ...
    def __call__(
        self, other: Incomplete, *additional: Incomplete
    ) -> Incomplete: ...
    def applyto(self, other: Incomplete) -> Incomplete: ...
    def __neg__(self) -> Incomplete: ...
    def negate(self) -> Incomplete: ...
    def __and__(self, other: Incomplete) -> Incomplete: ...
    def __or__(self, other: Incomplete) -> Incomplete: ...
    def __gt__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def equiv(
        self, other: Incomplete, prover: Incomplete | None = None
    ) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...
    def substitute_bindings(self, bindings: Incomplete) -> Incomplete: ...
    def typecheck(self, signature: Incomplete | None = None) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> None: ...
    def replace(
        self,
        variable: Incomplete,
        expression: Incomplete,
        replace_bound: bool = False,
        alpha_convert: bool = True,
    ) -> Incomplete: ...
    def normalize(self, newvars: Incomplete | None = None) -> Incomplete: ...
    def visit(self, function: Incomplete, combinator: Incomplete) -> None: ...
    def visit_structured(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def variables(self) -> Incomplete: ...
    def free(self) -> Incomplete: ...
    def constants(self) -> Incomplete: ...
    def predicates(self) -> Incomplete: ...
    def simplify(self) -> Incomplete: ...
    def make_VariableExpression(self, variable: Incomplete) -> Incomplete: ...

class ApplicationExpression(Expression):
    function: Incomplete
    argument: Incomplete
    def __init__(self, function: Incomplete, argument: Incomplete) -> None: ...
    def simplify(self) -> Incomplete: ...
    @property
    def type(self) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> Incomplete: ...
    def constants(self) -> Incomplete: ...
    def predicates(self) -> Incomplete: ...
    def visit(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete
    def uncurry(self) -> Incomplete: ...
    @property
    def pred(self) -> Incomplete: ...
    @property
    def args(self) -> Incomplete: ...
    def is_atom(self) -> Incomplete: ...

class AbstractVariableExpression(Expression):
    variable: Incomplete
    def __init__(self, variable: Incomplete) -> None: ...
    def simplify(self) -> Incomplete: ...
    def replace(
        self,
        variable: Incomplete,
        expression: Incomplete,
        replace_bound: bool = False,
        alpha_convert: bool = True,
    ) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> Incomplete: ...
    def predicates(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete

class IndividualVariableExpression(AbstractVariableExpression):
    type: Incomplete
    def free(self) -> Incomplete: ...
    def constants(self) -> Incomplete: ...

class FunctionVariableExpression(AbstractVariableExpression):
    type = ANY_TYPE
    def free(self) -> Incomplete: ...
    def constants(self) -> Incomplete: ...

class EventVariableExpression(IndividualVariableExpression):
    type = EVENT_TYPE

class ConstantExpression(AbstractVariableExpression):
    type = ENTITY_TYPE
    def free(self) -> Incomplete: ...
    def constants(self) -> Incomplete: ...

def VariableExpression(variable: Incomplete) -> Incomplete: ...

class VariableBinderExpression(Expression):
    variable: Incomplete
    term: Incomplete
    def __init__(self, variable: Incomplete, term: Incomplete) -> None: ...
    def replace(
        self,
        variable: Incomplete,
        expression: Incomplete,
        replace_bound: bool = False,
        alpha_convert: bool = True,
    ) -> Incomplete: ...
    def alpha_convert(self, newvar: Incomplete) -> Incomplete: ...
    def free(self) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> Incomplete: ...
    def visit(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def visit_structured(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete

class LambdaExpression(VariableBinderExpression):
    @property
    def type(self) -> Incomplete: ...

class QuantifiedExpression(VariableBinderExpression):
    @property
    def type(self) -> Incomplete: ...

class ExistsExpression(QuantifiedExpression):
    def getQuantifier(self) -> Incomplete: ...

class AllExpression(QuantifiedExpression):
    def getQuantifier(self) -> Incomplete: ...

class IotaExpression(QuantifiedExpression):
    def getQuantifier(self) -> Incomplete: ...

class NegatedExpression(Expression):
    term: Incomplete
    def __init__(self, term: Incomplete) -> None: ...
    @property
    def type(self) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> Incomplete: ...
    def visit(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def negate(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete

class BinaryExpression(Expression):
    first: Incomplete
    second: Incomplete
    def __init__(self, first: Incomplete, second: Incomplete) -> None: ...
    @property
    def type(self) -> Incomplete: ...
    def findtype(self, variable: Incomplete) -> Incomplete: ...
    def visit(
        self, function: Incomplete, combinator: Incomplete
    ) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    __hash__: Incomplete

class BooleanExpression(BinaryExpression): ...

class AndExpression(BooleanExpression):
    def getOp(self) -> Incomplete: ...

class OrExpression(BooleanExpression):
    def getOp(self) -> Incomplete: ...

class ImpExpression(BooleanExpression):
    def getOp(self) -> Incomplete: ...

class IffExpression(BooleanExpression):
    def getOp(self) -> Incomplete: ...

class EqualityExpression(BinaryExpression):
    def getOp(self) -> Incomplete: ...

class LogicalExpressionException(Exception):
    index: Incomplete
    def __init__(self, index: Incomplete, message: Incomplete) -> None: ...

class UnexpectedTokenException(LogicalExpressionException):
    def __init__(
        self,
        index: Incomplete,
        unexpected: Incomplete | None = None,
        expected: Incomplete | None = None,
        message: Incomplete | None = None,
    ) -> None: ...

class ExpectedMoreTokensException(LogicalExpressionException):
    def __init__(
        self, index: Incomplete, message: Incomplete | None = None
    ) -> None: ...

def is_indvar(expr: Incomplete) -> Incomplete: ...
def is_funcvar(expr: Incomplete) -> Incomplete: ...
def is_eventvar(expr: Incomplete) -> Incomplete: ...
def demo() -> None: ...
def demo_errors() -> None: ...
def demoException(s: Incomplete) -> None: ...
def printtype(ex: Incomplete) -> None: ...
