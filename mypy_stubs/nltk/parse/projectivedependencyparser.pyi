from collections.abc import Generator

from _typeshed import Incomplete

from nltk.grammar import (
    DependencyGrammar as DependencyGrammar,
)
from nltk.grammar import (
    DependencyProduction as DependencyProduction,
)
from nltk.grammar import (
    ProbabilisticDependencyGrammar as ProbabilisticDependencyGrammar,
)
from nltk.internals import raise_unorderable_types as raise_unorderable_types
from nltk.parse.dependencygraph import DependencyGraph as DependencyGraph

class DependencySpan:
    def __init__(
        self,
        start_index: Incomplete,
        end_index: Incomplete,
        head_index: Incomplete,
        arcs: Incomplete,
        tags: Incomplete,
    ) -> None: ...
    def head_index(self) -> Incomplete: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

class ChartCell:
    def __init__(self, x: Incomplete, y: Incomplete) -> None: ...
    def add(self, span: Incomplete) -> None: ...

class ProjectiveDependencyParser:
    def __init__(self, dependency_grammar: Incomplete) -> None: ...
    def parse(
        self, tokens: Incomplete
    ) -> Generator[Incomplete, None, None]: ...
    def concatenate(
        self, span1: Incomplete, span2: Incomplete
    ) -> Incomplete: ...

class ProbabilisticProjectiveDependencyParser:
    def __init__(self) -> None: ...
    def parse(self, tokens: Incomplete) -> Incomplete: ...
    def concatenate(
        self, span1: Incomplete, span2: Incomplete
    ) -> Incomplete: ...
    def train(self, graphs: Incomplete) -> None: ...
    def compute_prob(self, dg: Incomplete) -> Incomplete: ...

def demo() -> None: ...
def projective_rule_parse_demo() -> None: ...
def arity_parse_demo() -> None: ...
def projective_prob_parse_demo() -> None: ...
