from collections.abc import Generator

from _typeshed import Incomplete

from nltk.grammar import PCFG as PCFG
from nltk.grammar import is_nonterminal as is_nonterminal
from nltk.grammar import is_terminal as is_terminal
from nltk.internals import raise_unorderable_types as raise_unorderable_types
from nltk.parse.api import ParserI as ParserI
from nltk.tree import Tree as Tree
from nltk.util import OrderedDict as OrderedDict

class EdgeI:
    def __init__(self) -> None: ...
    def span(self) -> None: ...
    def start(self) -> None: ...
    def end(self) -> None: ...
    def length(self) -> None: ...
    def lhs(self) -> None: ...
    def rhs(self) -> None: ...
    def dot(self) -> None: ...
    def nextsym(self) -> None: ...
    def is_complete(self) -> None: ...
    def is_incomplete(self) -> None: ...
    def __eq__(self, other: Incomplete) -> Incomplete: ...
    def __ne__(self, other: Incomplete) -> Incomplete: ...
    def __lt__(self, other: Incomplete) -> Incomplete: ...
    def __hash__(self) -> Incomplete: ...

class TreeEdge(EdgeI):
    def __init__(
        self, span: Incomplete, lhs: Incomplete, rhs: Incomplete, dot: int = 0
    ) -> None: ...
    @staticmethod
    def from_production(
        production: Incomplete, index: Incomplete
    ) -> Incomplete: ...
    def move_dot_forward(self, new_en: Incomplete) -> Incomplete: ...
    def lhs(self) -> Incomplete: ...
    def span(self) -> Incomplete: ...
    def start(self) -> Incomplete: ...
    def end(self) -> Incomplete: ...
    def length(self) -> Incomplete: ...
    def rhs(self) -> Incomplete: ...
    def dot(self) -> Incomplete: ...
    def is_complete(self) -> Incomplete: ...
    def is_incomplete(self) -> Incomplete: ...
    def nextsym(self) -> Incomplete: ...

class LeafEdge(EdgeI):
    def __init__(self, leaf: Incomplete, index: Incomplete) -> None: ...
    def lhs(self) -> Incomplete: ...
    def span(self) -> Incomplete: ...
    def start(self) -> Incomplete: ...
    def end(self) -> Incomplete: ...
    def length(self) -> Incomplete: ...
    def rhs(self) -> Incomplete: ...
    def dot(self) -> Incomplete: ...
    def is_complete(self) -> Incomplete: ...
    def is_incomplete(self) -> Incomplete: ...
    def nextsym(self) -> None: ...

class Chart:
    def __init__(self, tokens: Incomplete) -> None: ...
    def initialize(self) -> None: ...
    def num_leaves(self) -> Incomplete: ...
    def leaf(self, index: Incomplete) -> Incomplete: ...
    def leaves(self) -> Incomplete: ...
    def edges(self) -> Incomplete: ...
    def iteredges(self) -> Incomplete: ...
    __iter__ = iteredges
    def num_edges(self) -> Incomplete: ...
    def select(self, **restrictions: Incomplete) -> Incomplete: ...
    def insert_with_backpointer(
        self,
        new_edge: Incomplete,
        previous_edge: Incomplete,
        child_edge: Incomplete,
    ) -> Incomplete: ...
    def insert(
        self, edge: Incomplete, *child_pointer_lists: Incomplete
    ) -> Incomplete: ...
    def parses(
        self, root: Incomplete, tree_class: Incomplete = ...
    ) -> Generator[Incomplete, Incomplete, None]: ...
    def trees(
        self,
        edge: Incomplete,
        tree_class: Incomplete = ...,
        complete: bool = False,
    ) -> Incomplete: ...
    def child_pointer_lists(self, edge: Incomplete) -> Incomplete: ...
    def pretty_format_edge(
        self, edge: Incomplete, width: Incomplete | None = None
    ) -> Incomplete: ...
    def pretty_format_leaves(
        self, width: Incomplete | None = None
    ) -> Incomplete: ...
    def pretty_format(self, width: Incomplete | None = None) -> Incomplete: ...
    def dot_digraph(self) -> Incomplete: ...

class ChartRuleI:
    def apply(
        self, chart: Incomplete, grammar: Incomplete, *edges: Incomplete
    ) -> None: ...
    def apply_everywhere(
        self, chart: Incomplete, grammar: Incomplete
    ) -> None: ...

class AbstractChartRule(ChartRuleI):
    def apply(
        self, chart: Incomplete, grammar: Incomplete, *edges: Incomplete
    ) -> None: ...
    def apply_everywhere(
        self, chart: Incomplete, grammar: Incomplete
    ) -> Generator[Incomplete, Incomplete, None]: ...

class FundamentalRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self,
        chart: Incomplete,
        grammar: Incomplete,
        left_edge: Incomplete,
        right_edge: Incomplete,
    ) -> Generator[Incomplete, None, None]: ...

class SingleEdgeFundamentalRule(FundamentalRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, Incomplete, None]: ...

class LeafInitRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class TopDownInitRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class TopDownPredictRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class CachedTopDownPredictRule(TopDownPredictRule):
    def __init__(self) -> None: ...
    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class BottomUpPredictRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class BottomUpPredictCombineRule(BottomUpPredictRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class EmptyPredictRule(AbstractChartRule):
    NUM_EDGES: int

    def apply(
        self, chart: Incomplete, grammar: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

class FilteredSingleEdgeFundamentalRule(SingleEdgeFundamentalRule): ...

class FilteredBottomUpPredictCombineRule(BottomUpPredictCombineRule):
    def apply(
        self, chart: Incomplete, grammar: Incomplete, edge: Incomplete
    ) -> Generator[Incomplete, None, None]: ...

TD_STRATEGY: Incomplete
BU_STRATEGY: Incomplete
BU_LC_STRATEGY: Incomplete
LC_STRATEGY: Incomplete

class ChartParser(ParserI):
    def __init__(
        self,
        grammar: Incomplete,
        strategy: Incomplete = ...,
        trace: int = 0,
        trace_chart_width: int = 50,
        use_agenda: bool = True,
        chart_class: Incomplete = ...,
    ) -> None: ...
    def grammar(self) -> Incomplete: ...
    def chart_parse(
        self, tokens: Incomplete, trace: Incomplete | None = None
    ) -> Incomplete: ...
    def parse(
        self, tokens: Incomplete, tree_class: Incomplete = ...
    ) -> Incomplete: ...

class TopDownChartParser(ChartParser):
    def __init__(
        self, grammar: Incomplete, **parser_args: Incomplete
    ) -> None: ...

class BottomUpChartParser(ChartParser):
    def __init__(
        self, grammar: Incomplete, **parser_args: Incomplete
    ) -> None: ...

class BottomUpLeftCornerChartParser(ChartParser):
    def __init__(
        self, grammar: Incomplete, **parser_args: Incomplete
    ) -> None: ...

class LeftCornerChartParser(ChartParser):
    def __init__(
        self, grammar: Incomplete, **parser_args: Incomplete
    ) -> None: ...

class SteppingChartParser(ChartParser):
    def __init__(
        self, grammar: Incomplete, strategy: Incomplete = [], trace: int = 0
    ) -> None: ...
    def initialize(self, tokens: Incomplete) -> None: ...
    def step(self) -> Generator[Incomplete, None, None]: ...
    def strategy(self) -> Incomplete: ...
    def grammar(self) -> Incomplete: ...
    def chart(self) -> Incomplete: ...
    def current_chartrule(self) -> Incomplete: ...
    def parses(self, tree_class: Incomplete = ...) -> Incomplete: ...
    def set_strategy(self, strategy: Incomplete) -> None: ...
    def set_grammar(self, grammar: Incomplete) -> None: ...
    def set_chart(self, chart: Incomplete) -> None: ...
    def parse(
        self, tokens: Incomplete, tree_class: Incomplete = ...
    ) -> Incomplete: ...

def demo_grammar() -> Incomplete: ...
def demo(
    choice: Incomplete | None = None,
    print_times: bool = True,
    print_grammar: bool = False,
    print_trees: bool = True,
    trace: int = 2,
    sent: str = "I saw John with a dog with my cookie",
    numparses: int = 5,
) -> Incomplete: ...
