from collections.abc import Generator

from _typeshed import Incomplete

from nltk.ccg.combinator import *
from nltk.ccg.combinator import BackwardApplication as BackwardApplication
from nltk.ccg.combinator import BackwardBx as BackwardBx
from nltk.ccg.combinator import BackwardComposition as BackwardComposition
from nltk.ccg.combinator import BackwardSx as BackwardSx
from nltk.ccg.combinator import BackwardT as BackwardT
from nltk.ccg.combinator import ForwardApplication as ForwardApplication
from nltk.ccg.combinator import ForwardComposition as ForwardComposition
from nltk.ccg.combinator import ForwardSubstitution as ForwardSubstitution
from nltk.ccg.combinator import ForwardT as ForwardT
from nltk.ccg.lexicon import Token as Token
from nltk.ccg.lexicon import fromstring as fromstring
from nltk.ccg.logic import *
from nltk.parse import ParserI as ParserI
from nltk.parse.chart import AbstractChartRule as AbstractChartRule
from nltk.parse.chart import Chart as Chart
from nltk.parse.chart import EdgeI as EdgeI
from nltk.sem.logic import *
from nltk.tree import Tree as Tree

class CCGEdge(EdgeI):
    def __init__(
        self, span: Incomplete, categ: Incomplete, rule: Incomplete
    ) -> None: ...
    def lhs(self) -> Incomplete: ...
    def span(self) -> Incomplete: ...
    def start(self) -> Incomplete: ...
    def end(self) -> Incomplete: ...
    def length(self) -> Incomplete: ...
    def rhs(self) -> Incomplete: ...
    def dot(self) -> Incomplete: ...
    def is_complete(self) -> Incomplete: ...
    def is_incomplete(self) -> Incomplete: ...
    def nextsym(self) -> None: ...
    def categ(self) -> Incomplete: ...
    def rule(self) -> Incomplete: ...

class CCGLeafEdge(EdgeI):
    def __init__(
        self, pos: Incomplete, token: Incomplete, leaf: Incomplete
    ) -> None: ...
    def lhs(self) -> Incomplete: ...
    def span(self) -> Incomplete: ...
    def start(self) -> Incomplete: ...
    def end(self) -> Incomplete: ...
    def length(self) -> Incomplete: ...
    def rhs(self) -> Incomplete: ...
    def dot(self) -> Incomplete: ...
    def is_complete(self) -> Incomplete: ...
    def is_incomplete(self) -> Incomplete: ...
    def nextsym(self) -> None: ...
    def token(self) -> Incomplete: ...
    def categ(self) -> Incomplete: ...
    def leaf(self) -> Incomplete: ...

class BinaryCombinatorRule(AbstractChartRule):
    NUMEDGES: int
    def __init__(self, combinator: Incomplete) -> None: ...
    def apply(
        self,
        chart: Incomplete,
        grammar: Incomplete,
        left_edge: Incomplete,
        right_edge: Incomplete,
    ) -> Generator[Incomplete, None, None]: ...

class ForwardTypeRaiseRule(AbstractChartRule):
    NUMEDGES: int
    def __init__(self) -> None: ...
    def apply(
        self,
        chart: Incomplete,
        grammar: Incomplete,
        left_edge: Incomplete,
        right_edge: Incomplete,
    ) -> Generator[Incomplete, None, None]: ...

class BackwardTypeRaiseRule(AbstractChartRule):
    NUMEDGES: int
    def __init__(self) -> None: ...
    def apply(
        self,
        chart: Incomplete,
        grammar: Incomplete,
        left_edge: Incomplete,
        right_edge: Incomplete,
    ) -> Generator[Incomplete, None, None]: ...

ApplicationRuleSet: Incomplete
CompositionRuleSet: Incomplete
SubstitutionRuleSet: Incomplete
TypeRaiseRuleSet: Incomplete
DefaultRuleSet: Incomplete

class CCGChartParser(ParserI):
    def __init__(
        self, lexicon: Incomplete, rules: Incomplete, trace: int = 0
    ) -> None: ...
    def lexicon(self) -> Incomplete: ...
    def parse(self, tokens: Incomplete) -> Incomplete: ...

class CCGChart(Chart):
    def __init__(self, tokens: Incomplete) -> None: ...

def compute_semantics(
    children: Incomplete, edge: Incomplete
) -> Incomplete: ...
def printCCGDerivation(tree: Incomplete) -> None: ...
def printCCGTree(lwidth: Incomplete, tree: Incomplete) -> Incomplete: ...

lex: Incomplete

def demo() -> None: ...
