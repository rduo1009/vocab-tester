import types
import zipfile
from abc import ABCMeta, abstractmethod
from gzip import GzipFile

from _typeshed import Incomplete

__all__ = [
    "path",
    "PathPointer",
    "FileSystemPathPointer",
    "BufferedGzipFile",
    "GzipFileSystemPathPointer",
    "GzipFileSystemPathPointer",
    "find",
    "retrieve",
    "FORMATS",
    "AUTO_FORMATS",
    "load",
    "show_cfg",
    "clear_cache",
    "LazyLoader",
    "OpenOnDemandZipFile",
    "GzipFileSystemPathPointer",
    "SeekableUnicodeStreamReader",
]

path: Incomplete

class PathPointer(metaclass=ABCMeta):
    @abstractmethod
    def open(self, encoding: Incomplete | None = None) -> Incomplete: ...
    @abstractmethod
    def file_size(self) -> Incomplete: ...
    @abstractmethod
    def join(self, fileid: Incomplete) -> Incomplete: ...

class FileSystemPathPointer(PathPointer, str):
    def __init__(self, _path: Incomplete) -> None: ...
    @property
    def path(self) -> Incomplete: ...
    def open(self, encoding: Incomplete | None = None) -> Incomplete: ...
    def file_size(self) -> Incomplete: ...
    def join(self, fileid: Incomplete) -> Incomplete: ...

class BufferedGzipFile(GzipFile):
    def __init__(
        self,
        filename: Incomplete | None = None,
        mode: Incomplete | None = None,
        compresslevel: int = 9,
        fileobj: Incomplete | None = None,
        **kwargs: Incomplete,
    ) -> None: ...
    def write(self, data: Incomplete) -> None: ...

class GzipFileSystemPathPointer(FileSystemPathPointer):
    def open(self, encoding: Incomplete | None = None) -> Incomplete: ...

class ZipFilePathPointer(PathPointer):
    def __init__(self, zipfile: Incomplete, entry: str = "") -> None: ...
    @property
    def zipfile(self) -> Incomplete: ...
    @property
    def entry(self) -> Incomplete: ...
    def open(self, encoding: Incomplete | None = None) -> Incomplete: ...
    def file_size(self) -> Incomplete: ...
    def join(self, fileid: Incomplete) -> Incomplete: ...

def find(
    resource_name: Incomplete, paths: Incomplete | None = None
) -> Incomplete: ...
def retrieve(
    resource_url: Incomplete,
    filename: Incomplete | None = None,
    verbose: bool = True,
) -> None: ...

FORMATS: Incomplete
AUTO_FORMATS: Incomplete

def load(
    resource_url: Incomplete,
    format: str = "auto",
    cache: bool = True,
    verbose: bool = False,
    logic_parser: Incomplete | None = None,
    fstruct_reader: Incomplete | None = None,
    encoding: Incomplete | None = None,
) -> Incomplete: ...
def show_cfg(resource_url: Incomplete, escape: str = "##") -> None: ...
def clear_cache() -> None: ...

class LazyLoader:
    def __init__(self, _path: Incomplete) -> None: ...
    def __getattr__(self, attr: Incomplete) -> Incomplete: ...

class OpenOnDemandZipFile(zipfile.ZipFile):
    def __init__(self, filename: Incomplete) -> None: ...
    fp: Incomplete
    def read(self, name: Incomplete) -> Incomplete: ...
    def write(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...
    def writestr(self, *args: Incomplete, **kwargs: Incomplete) -> None: ...

class SeekableUnicodeStreamReader:
    DEBUG: bool
    stream: Incomplete
    encoding: Incomplete
    errors: Incomplete
    decode: Incomplete
    bytebuffer: bytes
    linebuffer: Incomplete
    def __init__(
        self, stream: Incomplete, encoding: Incomplete, errors: str = "strict"
    ) -> None: ...
    def read(self, size: Incomplete | None = None) -> Incomplete: ...
    def discard_line(self) -> None: ...
    def readline(self, size: Incomplete | None = None) -> Incomplete: ...
    def readlines(
        self, sizehint: Incomplete | None = None, keepends: bool = True
    ) -> Incomplete: ...
    def next(self) -> Incomplete: ...
    def __next__(self) -> Incomplete: ...
    def __iter__(self) -> Incomplete: ...
    def __del__(self) -> None: ...
    def __enter__(self) -> Incomplete: ...
    def __exit__(
        self,
        type: type[BaseException] | None,
        value: BaseException | None,
        traceback: types.TracebackType | None,
    ) -> None: ...
    def xreadlines(self) -> Incomplete: ...
    @property
    def closed(self) -> Incomplete: ...
    @property
    def name(self) -> Incomplete: ...
    @property
    def mode(self) -> Incomplete: ...
    def close(self) -> None: ...
    def seek(self, offset: Incomplete, whence: int = 0) -> None: ...
    def char_seek_forward(self, offset: Incomplete) -> None: ...
    def tell(self) -> Incomplete: ...
